AI Agent Implementation Prompt: IRISVOICE Navigation Transition System

 Mission Overview

You are an AI coding agent implementing a custom animation system for the IRISVOICE navigation menu. Your task is to add 5 NEW transition animations to the existing working navigation system WITHOUT breaking any existing functionality.
Critical: The navigation system was just debugged after 28 hours of work. You MUST NOT break it.


 Table of Contents

1. Critical Safety Rules

2. Product Requirements

3. Technical Specifications

4. Implementation Phases

5. Testing Requirements

6. Iteration Loop Process

7. Helper Functions & Code Examples

8. Success Criteria



CRITICAL SAFETY RULES


 ABSOLUTE RULES - NEVER VIOLATE

Rule 1: Protected Files (READ-ONLY)
YOU MUST NEVER MODIFY THESE FILES:

contexts/NavigationContext.tsx components/navigation-controller.tsx hooks/useNavigationController.ts (if exists)

Why: These files contain the navigation state machine that was just debugged. Any changes will break L2-L3 navigation.
If you need info from these files: READ them, but NEVER write to them.

Exception: NONE. No exceptions. These are read-only.



Rule 2: The Radial Spin Animation is Sacred
YOU MUST NEVER MODIFY:

The existing spiral/radial animation in components/hexagonal-node.tsx . It currently looks like this:

const spiralVariants = {
collapsed: { x: 0, y: 0, scale: 0.5, opacity: 0, rotate: 0 }, expanded: {
x: pos.x,
y: pos.y, scale: 1,
opacity: 1,
rotate: pos.rotation, transition: { ... }
},
exit: {
x: 0,
y: 0,
scale: 0.5,
opacity: 0,
rotate: -360, transition: { ... }
}
}


Why: This animation works perfectly. It's the default and fallback.

What you CAN do: Extract it into the variant factory as a REFERENCE, but the original must remain unchanged as a fallback.


Rule 3: Test After EVERY Change
MANDATORY TESTING SEQUENCE:

After EVERY code change, you MUST:

1. Compile Check:

npm run build # OR
npx tsc --noEmit


2. Runtime Check:

npm run dev


3. Navigation Test:

Click IrisOrb ? Verify L2 nodes appear

Click any main node ? Verify L3 nodes appear

Click IrisOrb again ? Verify navigation returns to L2

Click IrisOrb again ? Verify collapse to L1

4. Console Check:

Open browser DevTools console

Look for ANY errors or warnings

If found, STOP and fix immediately



Rule 4: One Change at a Time
YOU MUST:

Make ONE logical change per iteration

Test that change fully before proceeding

Never batch multiple changes together

Never skip testing "because it should work"

Example of CORRECT iteration:

Iteration 1: Create TransitionContext.tsx Iteration 2: Test import of TransitionContext Iteration 3: Wrap app with provider
Iteration 4: Test provider in DevTools Iteration 5: Add keyboard shortcut Iteration 6: Test keyboard shortcut

Example of WRONG iteration:

Iteration 1: Create context, wrap app, add shortcuts, implement all transitions  TOO MUCH AT ONCE



Rule 5: Console Logging is Mandatory
YOU MUST:

Add console.log() statements for EVERY significant action:

//  GOOD
function setTransitionType(type: TransitionType) { console.log('[TransitionContext] Changing type:', currentType, '?', type) setCurrentType(type)
console.log('[TransitionContext] Type changed successfully')
}

//  BAD
function setTransitionType(type: TransitionType) { setCurrentType(type)
}


Log format:

[ComponentName] Action: details


Why: Debugging is 10x easier with verbose logs.



Rule 6: Rollback on Any Error
IF YOU SEE ANY OF THESE:

TypeScript compilation error

 Runtime error in console  Navigation stops working  Infinite re-render loop
 "Cannot read property" errors

React warnings about keys, hooks, etc.

THEN YOU MUST:

1. STOP immediately

2. Identify the file you just changed

3. Revert that file to previous state

4. Verify L2-L3 navigation works again

5. Re-approach the change differently

Never: Try to "fix forward" by adding more code. Revert first, then try again.



Rule 7: Iteration Template
Use this template for EVERY iteration:

## Iteration [N]: [Phase] - [Action]

**Current Goal:** [What are you trying to accomplish]

**Files to Modify:** [List exact files]

**Changes:**
1. [Specific change 1]
2. [Specific change 2]

**Code:**
```typescript
[Show the actual code changes]


Testing:

[Commands you'll run]

Expected Console Output:

[What you expect to see in console]


Navigation Test:

L1 ? L2 works

L2 ? L3 works

L3 ? L2 works

L2 ? L1 works

Success Criteria:

No TypeScript errors

No runtime errors

Console logs show expected output

   Navigation still works Result: [Actual outcome] Next Step: [What comes next]

---

# PRODUCT REQUIREMENTS

## Overview

Implement 6 transition animations for the IRISVOICE navigation system:

1. **Radial Spin** (Default) - Already working 
2. **Clockwork** - Mechanical gear stepping
3. **Slot Machine** - Vertical blur with radial lock
4. **Holographic Phase** - Glitch interference effects
5. **Pop Out** - Spin + scale with fade-at-peak
6. **Pure Fade** - Minimal fast transition

---

## Transition Specifications

### 1. Radial Spin (Default)  - DO NOT MODIFY

**Status:** Already implemented and working

**Duration:** 1.5s

**Characteristics:**
- Fibonacci spiral emergence with dual rotation
- 2 full clockwise rotations while expanding
- Counter-rotation of content to keep icons upright
- Slight overshoot at end (scale 1.05?1.0)

**DO NOT TOUCH THIS ANIMATION - IT WORKS**

---

### 2. Clockwork  - TO IMPLEMENT

**Priority:** HIGH (user's favorite)

**Duration:** 1.2s

**Concept:** Mechanical gear-tooth stepping with discrete angular locking

**Phases:**

1. **Gear Mesh (0-40%):**
- Nodes appear at center
- Scale in discrete steps: 0?0.4?0.6?0.8
- 12 visible "ticks"

2. **Radial Steps (40-80%):**
- 5 discrete radial jumps
- Radii: 0px ? 50px ? 100px ? 150px ? 200px
- Each step: rotate 15° (gear turn)
- Total 90° rotation during expansion

3. **Lock-in (80-100%):**
- Rotation resets to 0° (gear "clicks")
- Scale: 1.02?1.0 (mechanical snap)
- Spring bounce

**Implementation:**

```typescript
const clockworkVariant = { collapsed: {

scale: 0,
rotate: 0,
x: 0,
y: 0
},
expanded: (custom: CustomProps) => ({
x: [0, 50, 100, 150, 200].map(r => Math.cos(custom.angle * Math.PI / 180) * r
y: [0, 50, 100, 150, 200].map(r => Math.sin(custom.angle * Math.PI / 180) * r
rotate: [0, 15, 30, 45, 60, 75, 90, 0], // Gear rotates then resets
scale: [0, 0.4, 0.6, 0.8, 0.9, 0.95, 1.02, 1],
transition: { duration: 1.2,
times: [0, 0.15, 0.3, 0.45, 0.6, 0.75, 0.9, 1],
delay: custom.index * 0.08
}
}),
exit: { scale: 0,
rotate: -90,
opacity: 0, transition: {
duration: 0.8, ease: 'easeIn'
}
}
};


Helper Functions Needed:

function generateClockworkX(angle: number): number[] { const radii = [0, 50, 100, 150, 200];
const angleRad = (angle * Math.PI) / 180; return radii.map(r => Math.cos(angleRad) * r);
}

function generateClockworkY(angle: number): number[] { const radii = [0, 50, 100, 150, 200];
const angleRad = (angle * Math.PI) / 180; return radii.map(r => Math.sin(angleRad) * r);
}


Visual Polish:

Optional: Mechanical "tick" sound every 100ms

Content must counter-rotate to stay upright

Critical: Movement is purely radial along final angle vectors (no spiral)



3. Slot Machine - TO IMPLEMENT
Priority: MEDIUM

Duration: 1.6s

Concept: Vertical motion blur with radial lock-in (like slot machine reels)

Phases:

1. Intense Blur (0-30%):

Vertical motion blur: 20px

Nodes stacked at center

2. Spin (30-70%):

Rapid movement along angle vectors

Sine-wave oscillation (±50px wobble on Y-axis)

Blur stays at 20px

3. Snap Decision (70-85%):

Deceleration

Blur reduces: 20px?10px?5px

Wobble amplitude reduces

4. Lock-in (85-100%):

Blur clears to 0px

Bounce: scale 0.98?1.02?1.0

Bloom glow flash

Implementation:

const slotMachineVariant = { collapsed: {
scale: 0,
y: 0,
x: 0,

filter: 'blur(0px)'
},
expanded: (custom: CustomProps) => {
const angleRad = (custom.angle * Math.PI) / 180; const finalX = Math.cos(angleRad) * 200;
const finalY = Math.sin(angleRad) * 200;

return {
x: finalX, y: [
0,
Math.sin(angleRad) * 50,	// Wobble high Math.sin(angleRad) * -50,	// Wobble low Math.sin(angleRad) * 30,
Math.sin(angleRad) * -20, finalY
],
scale: [0, 0.8, 0.9, 0.95, 0.98, 1.02, 1],
filter: [ 'blur(0px)',
'blur(20px)',
'blur(20px)',
'blur(10px)',
'blur(5px)',
'blur(0px)'
],
transition: { duration: 1.6,
times: [0, 0.2, 0.4, 0.6, 0.8, 0.9, 1],
ease: [0.23, 1, 0.32, 1],
delay: custom.index * 0.05
}
};
},
exit: {
y: 100,
opacity: 0,
filter: 'blur(10px)', transition: {
duration: 0.6, ease: 'easeIn'
}
}
};


Helper Function:

function generateSlotWobble(angle: number): number[] { const angleRad = (angle * Math.PI) / 180;
const finalY = Math.sin(angleRad) * 200;

return [

0,Math.sin(angleRad)*50,Math.sin(angleRad)*-50,Math.sin(angleRad)*30,Math.sin(angleRad)*-20,finalY];
}


Visual Polish:

Bloom on lock-in: box-shadow: 0 0 30px currentColor

Ghost icons during blur (optional)

Performance Warning:

Blur is expensive (not GPU-accelerated)

If FPS < 50, reduce blur to 10px max

Profile early with Chrome DevTools



4. Holographic Phase - TO IMPLEMENT
Priority: LOW (implement last - most complex)

Duration: 1.8s

Concept: Nodes materialize through interference patterns

Phases:

1. Wireframe (0-40%):

Wireframe meshes at center

Scanline interference

rotateX: 90° (edge-on view)

Hue rotation creates color shifting

2. Glitch Teleport (40-60%):

RGB split effect

Hue rotates: 0°?180°?0°

Opacity flickers: 0.1?0.8?0.4

Scale jumps: 0.5?1.2

3. Phase Stabilization (60-80%):

rotateX flattens to 0°

Opacity stabilizes

Brief blur (2px)

4. Solidification (80-100%):

All filters clear

Final saturate boost

Lock at opacity 1, scale 1

Implementation:

const holographicVariant = { collapsed: {
opacity: 0,
rotateX: 90,
filter: 'hue-rotate(90deg) brightness(2)', x: 0,
y: 0,
scale: 0
},
expanded: (custom: CustomProps) => {
const angleRad = (custom.angle * Math.PI) / 180; const finalX = Math.cos(angleRad) * 200;
const finalY = Math.sin(angleRad) * 200;

return {
x: finalX, y: finalY,
opacity: [0, 0.3, 0.1, 0.8, 0.4, 1, 0.9, 1],
scale: [0, 0.5, 0.5, 1.2, 0.9, 1.05, 0.98, 1],
rotateX: [90, 45, 45, 0, 0, 0, 0, 0],
filter: [

'hue-rotate(90deg) brightness(2)', 'hue-rotate(0deg) brightness(1.5)', 'hue-rotate(180deg) brightness(2)', 'hue-rotate(0deg) brightness(1)', 'blur(2px)',
'blur(0px)',
'saturate(1.5)', 'saturate(1)'
],
transition: { duration: 1.8,
times: [0, 0.2, 0.4, 0.5, 0.6, 0.8, 0.9, 1],
ease: 'linear',
delay: custom.index * 0.1
}
};
},
exit: { opacity: 0,
rotateX: -90,
filter: 'hue-rotate(180deg) brightness(0)', transition: {
duration: 0.8, ease: 'easeIn'
}
}
};


Visual Polish:

Scanline overlay during wireframe

RGB split: text-shadow: 2px 0 red, -2px 0 blue

Glassmorphism on solidification

Performance Warning:

8 filter keyframes is very complex

If FPS < 45, reduce to 4 keyframes

Test early and simplify if needed



5. Pop Out - TO IMPLEMENT

Priority: MEDIUM

Duration: 1.0s

Concept: Spin on own axis while scaling, fade out at peak, then settle Signature Feature: Opacity dips at peak scale (creates "explosion" effect) Phases:
1. Emerge (0-20%):

Scale: 0?0.3

Rotate: 0?180°

Opacity: 0?0.5

2. Explosive Growth (20-40%):

Scale: 0.3?0.6?1.4 (overshoots!)

Rotate: 180?360?540°

Opacity: 0.5?1

3. Peak Fade (40-60%):  SIGNATURE MOMENT

Scale at peak: 1.4

Opacity drops to 0.6 (fade!)

Rotate: 540°

4. Recovery (60-80%):

Scale: 1.4?1.2

Rotate: 540?720°

Opacity returns to 1

5. Settle (80-100%):

Scale: 1.2?1.0

Rotate: holds at 720°

Opacity: solid at 1

Implementation:

const popOutVariant = { collapsed: {
scale: 0,
rotate: 0,
opacity: 0,
x: 0,
y: 0
},
expanded: (custom: CustomProps) => {
const angleRad = (custom.angle * Math.PI) / 180; const finalX = Math.cos(angleRad) * 200;
const finalY = Math.sin(angleRad) * 200;

return {
x: finalX, y: finalY,
scale: [0, 0.3, 0.6, 1.4, 1.2, 1.0],
rotate: [0, 180, 360, 540, 720, 720],
opacity: [0, 0.5, 1, 0.6, 1, 1], //  The magic fade! transition: {
duration: 1.0,
times: [0, 0.2, 0.4, 0.6, 0.8, 1.0],
ease: [0.34, 1.56, 0.64, 1], // Bouncy easing delay: custom.index * 0.08
}
};
},
exit: { scale: 0,
rotate: -360,
opacity: 0, transition: {
duration: 0.5, ease: 'easeIn'
}
}
};


Visual Polish:

Brief glow at peak scale

Optional "pop" sound effect

Content must counter-rotate to stay upright

Why This Works:

Simple to implement (only transform + opacity)

Visually distinctive (fade-at-peak is unique)

Performant (GPU-accelerated)

Energetic, bouncy feel



6. Pure Fade - TO IMPLEMENT
Priority: HIGH (implement first - easiest)

Duration: 0.3s

Concept: Fastest, most minimal transition

Implementation:

const pureFadeVariant = { collapsed: {
opacity: 0,
scale: 0.8,
x: 0,
y: 0
},
expanded: (custom: CustomProps) => {
const angleRad = (custom.angle * Math.PI) / 180; const finalX = Math.cos(angleRad) * 200;
const finalY = Math.sin(angleRad) * 200;

return {
x: finalX, y: finalY, opacity: 1,
scale: 1, transition: {
duration: 0.3, ease: 'linear',
delay: custom.index * 0.02
}
};
},
exit: { opacity: 0,
scale: 0.8, transition: {

duration: 0.2, ease: 'linear'
}
}
};


Use Cases:

Reduced motion accessibility

Performance mode

Speed-focused users

Fallback for older browsers

Why Implement First:

Simplest code (builds confidence)

No complex effects

Good learning example

Tests infrastructure



Technical Architecture

Files to Create


contexts/TransitionContext.tsx	- State management utils/transition-variants.ts	- All 6 variant functions
utils/animation-helpers.ts	- Helper functions (clockwork, slot wobbl


Files to Modify

components/hexagonal-node.tsx	- Use variant factory components/hexagonal-control-center.tsx - Add keyboard shortcuts app/layout.tsx	- Add TransitionProvider


Files to NEVER Touch

contexts/NavigationContext.tsx	- PROTECTED

components/navigation-controller.tsx	- PROTECTED




TransitionContext Implementation

// contexts/TransitionContext.tsx
import { createContext, useContext, useState, ReactNode } from 'react'; export type TransitionType =
| 'radial-spin'
| 'clockwork'
| 'slot-machine'
| 'holographic'
| 'pop-out'
| 'pure-fade';

interface TransitionContextValue { transitionType: TransitionType;
setTransitionType: (type: TransitionType) => void; cycleTransition: () => void;
}
const TransitionContext = createContext<TransitionContextValue | undefined>(undef const TRANSITION_ORDER: TransitionType[] = [
'radial-spin', 'clockwork', 'slot-machine', 'holographic', 'pop-out', 'pure-fade'
];

export function TransitionProvider({ children }: { children: ReactNode }) {
const [transitionType, setTransitionType] = useState<TransitionType>('radial-sp console.log('[TransitionContext] Current transition type:', transitionType);
const cycleTransition = () => {
const currentIndex = TRANSITION_ORDER.indexOf(transitionType); const nextIndex = (currentIndex + 1) % TRANSITION_ORDER.length; const nextType = TRANSITION_ORDER[nextIndex];

console.log('[TransitionContext] Cycling:', transitionType, '?', nextType);

setTransitionType(nextType);
};

return (
<TransitionContext.Provider value={{ transitionType, setTransitionType, cycle
{children}
</TransitionContext.Provider>
);
}

export function useTransition() {
const context = useContext(TransitionContext); if (!context) {
throw new Error('useTransition must be used within TransitionProvider');
}
return context;
}




Variant Factory Implementation

// utils/transition-variants.ts
import type { Variants } from 'framer-motion'; export type TransitionType =
| 'radial-spin'
| 'clockwork'
| 'slot-machine'
| 'holographic'
| 'pop-out'
| 'pure-fade';

export interface CustomProps {
angle: number;	// -90, -30, 30, 90, 150, 210 index: number;	// 0-5 (stagger index) radius: number;	// 200 (final radius)
}

// Import helpers import {
generateClockworkX, generateClockworkY, generateSlotWobble
} from './animation-helpers';

export function getTransitionVariants( type: TransitionType,
custom: CustomProps
): Variants {
console.log(`[getTransitionVariants] Type: ${type}, Index: ${custom.index}`);

switch(type) {
case 'radial-spin':
// Return existing working spiral variants
// DO NOT MODIFY - just reference the existing implementation return getRadialSpinVariants(custom);

case 'clockwork': return {
collapsed: { scale: 0, rotate: 0, x: 0, y: 0 }, expanded: {
x: generateClockworkX(custom.angle), y: generateClockworkY(custom.angle),
scale: [0, 0.4, 0.6, 0.8, 0.9, 0.95, 1.02, 1],
rotate: [0, 15, 30, 45, 60, 75, 90, 0],
transition: { duration: 1.2,
times: [0, 0.15, 0.3, 0.45, 0.6, 0.75, 0.9, 1],
delay: custom.index * 0.08
}
},
exit: { scale: 0,
rotate: -90,
opacity: 0,
transition: { duration: 0.8, ease: 'easeIn' }
}
};

case 'slot-machine':
const angleRad1 = (custom.angle * Math.PI) / 180; const finalX1 = Math.cos(angleRad1) * 200;

return {
collapsed: { scale: 0, y: 0, x: 0, filter: 'blur(0px)' }, expanded: {
x: finalX1,
y: generateSlotWobble(custom.angle), scale: [0, 0.8, 0.9, 0.95, 0.98, 1.02, 1],
filter: [ 'blur(0px)',

'blur(20px)',
'blur(20px)',
'blur(10px)',
'blur(5px)',
'blur(0px)'
],
transition: { duration: 1.6,
times: [0, 0.2, 0.4, 0.6, 0.8, 0.9, 1],
ease: [0.23, 1, 0.32, 1],
delay: custom.index * 0.05
}
},
exit: {
y: 100,
opacity: 0,
filter: 'blur(10px)',
transition: { duration: 0.6, ease: 'easeIn' }
}
};

case 'holographic':
const angleRad2 = (custom.angle * Math.PI) / 180; const finalX2 = Math.cos(angleRad2) * 200;
const finalY2 = Math.sin(angleRad2) * 200;

return { collapsed: {
opacity: 0,
rotateX: 90,
filter: 'hue-rotate(90deg) brightness(2)', x: 0,
y: 0,
scale: 0
},
expanded: { x: finalX2, y: finalY2,
opacity: [0, 0.3, 0.1, 0.8, 0.4, 1, 0.9, 1],
scale: [0, 0.5, 0.5, 1.2, 0.9, 1.05, 0.98, 1],
rotateX: [90, 45, 45, 0, 0, 0, 0, 0],
filter: [
'hue-rotate(90deg) brightness(2)', 'hue-rotate(0deg) brightness(1.5)', 'hue-rotate(180deg) brightness(2)', 'hue-rotate(0deg) brightness(1)', 'blur(2px)',

'blur(0px)',
'saturate(1.5)', 'saturate(1)'
],
transition: { duration: 1.8,
times: [0, 0.2, 0.4, 0.5, 0.6, 0.8, 0.9, 1],
ease: 'linear',
delay: custom.index * 0.1
}
},
exit: { opacity: 0,
rotateX: -90,
filter: 'hue-rotate(180deg) brightness(0)', transition: { duration: 0.8, ease: 'easeIn' }
}
};

case 'pop-out':
const angleRad3 = (custom.angle * Math.PI) / 180; const finalX3 = Math.cos(angleRad3) * 200;
const finalY3 = Math.sin(angleRad3) * 200;

return {
collapsed: { scale: 0, rotate: 0, opacity: 0, x: 0, y: 0 }, expanded: {
x: finalX3, y: finalY3,
scale: [0, 0.3, 0.6, 1.4, 1.2, 1.0],
rotate: [0, 180, 360, 540, 720, 720],
opacity: [0, 0.5, 1, 0.6, 1, 1], // Fade at peak! transition: {
duration: 1.0,
times: [0, 0.2, 0.4, 0.6, 0.8, 1.0],
ease: [0.34, 1.56, 0.64, 1],
delay: custom.index * 0.08
}
},
exit: { scale: 0,
rotate: -360,
opacity: 0,
transition: { duration: 0.5, ease: 'easeIn' }
}
};

case 'pure-fade':
const angleRad4 = (custom.angle * Math.PI) / 180; const finalX4 = Math.cos(angleRad4) * 200;
const finalY4 = Math.sin(angleRad4) * 200;

return {
collapsed: { opacity: 0, scale: 0.8, x: 0, y: 0 }, expanded: {
x: finalX4, y: finalY4, opacity: 1,
scale: 1, transition: {
duration: 0.3, ease: 'linear',
delay: custom.index * 0.02
}
},
exit: { opacity: 0,
scale: 0.8,
transition: { duration: 0.2, ease: 'linear' }
}
};
}
}

// Placeholder for existing radial spin
function getRadialSpinVariants(custom: CustomProps): Variants {
// This should reference the EXISTING spiral variants
// from hexagonal-node.tsx - don't reimplement
// Just return the current working implementation console.log('[getRadialSpinVariants] Using existing implementation'); return {} as Variants; // Replace with actual reference
}




Animation Helpers Implementation

// utils/animation-helpers.ts

/**
* Clockwork transition helper - generates discrete radial steps
*/
export function generateClockworkX(angle: number): number[] {

const radii = [0, 50, 100, 150, 200]; const angleRad = (angle * Math.PI) / 180;
const positions = radii.map(r => Math.cos(angleRad) * r);

console.log(`[Clockwork] X positions for angle ${angle}:`, positions); return positions;
}

export function generateClockworkY(angle: number): number[] { const radii = [0, 50, 100, 150, 200];
const angleRad = (angle * Math.PI) / 180;
const positions = radii.map(r => Math.sin(angleRad) * r);

console.log(`[Clockwork] Y positions for angle ${angle}:`, positions); return positions;
}

/**
* Slot Machine transition helper - generates wobble pattern
*/
export function generateSlotWobble(angle: number): number[] { const angleRad = (angle * Math.PI) / 180;
const finalY = Math.sin(angleRad) * 200;

const wobble = [
0,	// Center
Math.sin(angleRad) * 50,	// High wobble Math.sin(angleRad) * -50,	// Low wobble Math.sin(angleRad) * 30,	// Settling Math.sin(angleRad) * -20,	// Final wobble finalY		// Final position
];

console.log(`[SlotMachine] Wobble for angle ${angle}:`, wobble); return wobble;
}




Keyboard Shortcuts Implementation

// Add to hexagonal-control-center.tsx

import { useTransition } from '@/contexts/TransitionContext';

// Inside component

const { transitionType, setTransitionType, cycleTransition } = useTransition();

useEffect(() => {
const handleKeyPress = (e: KeyboardEvent) => {
// Only in development mode
if (process.env.NODE_ENV !== 'development') return;

// Ctrl+Shift+T to cycle
if (e.ctrlKey && e.shiftKey && e.key === 'T') { e.preventDefault();
console.log('[Keyboard] Cycling transition'); cycleTransition();
}

// Ctrl+Shift+1-6 for direct selection
if (e.ctrlKey && e.shiftKey && e.key >= '1' && e.key <= '6') { e.preventDefault();
const types: TransitionType[] = [ 'radial-spin',
'clockwork', 'slot-machine', 'holographic', 'pop-out', 'pure-fade'
];
const index = parseInt(e.key) - 1; console.log('[Keyboard] Jumping to:', types[index]); setTransitionType(types[index]);
}

// Ctrl+Shift+R to reset
if (e.ctrlKey && e.shiftKey && e.key === 'R') { e.preventDefault();
console.log('[Keyboard] Resetting to default'); setTransitionType('radial-spin');
}
};

window.addEventListener('keydown', handleKeyPress);
return () => window.removeEventListener('keydown', handleKeyPress);
}, [transitionType, setTransitionType, cycleTransition]);

// Dev indicator UI
{process.env.NODE_ENV === 'development' && (
<div style={{ position: 'fixed', top: 10,

right: 10,
padding: '8px 12px', background: 'rgba(0,0,0,0.8)', color: glowColor,
fontSize: 10, fontFamily: 'monospace', borderRadius: 4,
zIndex: 9999, pointerEvents: 'none'
}}>
<div style={{ fontWeight: 'bold', marginBottom: 4 }}> Transition: {transitionType.toUpperCase()}
</div>
<div style={{ fontSize: 8, opacity: 0.6 }}> Ctrl+Shift+T cycle
</div>
<div style={{ fontSize: 8, opacity: 0.6 }}> Ctrl+Shift+1-6 jump
</div>
</div>
)}




Content Counter-Rotation
Required for transitions with Z-axis rotation:

// In hexagonal-node.tsx
const needsCounterRotation = ['radial-spin', 'clockwork', 'pop-out'].includes(tra const containerRotation = getContainerRotation(transitionType); // 720 or 90 or 0 return (
<motion.div
className="node-container" variants={containerVariants}
>
{needsCounterRotation ? (
<motion.div className="node-content"
animate={{ rotate: -containerRotation }} style={{ transformOrigin: 'center center' }}
>
<Icon />
<Label />

</motion.div>
) : (
<div className="node-content">
<Icon />
<Label />
</div>
)}
</motion.div>
);




IMPLEMENTATION PHASES

Phase 1: Infrastructure (2 hours) 

Goal: Set up context and controls WITHOUT breaking navigation

Iteration 1.1: Create TransitionContext
Action:

# Create file
touch contexts/TransitionContext.tsx


Code: [See TransitionContext Implementation above]

Test:

npx tsc --noEmit


Expected: No TypeScript errors

Success: File compiles correctly



Iteration 1.2: Wrap App with Provider
Action: Modify app/layout.tsx or root provider file

Code:

import { TransitionProvider } from '@/contexts/TransitionContext';

// Wrap existing providers
<TransitionProvider>
<NavigationProvider>
{/* existing app */}
</NavigationProvider>
</TransitionProvider>


Test:

npm run dev
# Open browser console


Expected Console Output:

[TransitionContext] Current transition type: radial-spin


Navigation Test:

L1 ? L2 works

L2 ? L3 works

L3 ? L2 works

L2 ? L1 works

Success: App loads, navigation works, console shows transition type



Iteration 1.3: Add Keyboard Shortcuts
Action: Add keyboard event listeners to hexagonal-control-center.tsx

Code: [See Keyboard Shortcuts Implementation above]

Test:

npm run dev
# Press Ctrl+Shift+T multiple times # Check dev indicator appears

Expected Console Output:

[Keyboard] Cycling transition

[TransitionContext] Cycling: radial-spin ? clockwork [TransitionContext] Current transition type: clockwork

Success: Indicator shows, keyboard works, navigation still works



Iteration 1.4: Create Animation Helpers
Action:

touch utils/animation-helpers.ts


Code: [See Animation Helpers Implementation above]

Test:

npx tsc --noEmit


Success: File compiles, functions export correctly



Phase 2: Simple Transitions (4-5 hours) 

Iteration 2.1: Create Variant Factory Skeleton
Action:

touch utils/transition-variants.ts


Code:

// Start with just Pure Fade and Radial Spin
export function getTransitionVariants(type: TransitionType, custom: CustomProps) console.log(`[Variants] Getting ${type} for index ${custom.index}`);

switch(type) {
case 'radial-spin':
  return getRadialSpinVariants(custom); case 'pure-fade':
  return getPureFadeVariants(custom); default:
return getRadialSpinVariants(custom);
}

}


Test:

npx tsc --noEmit


Success: Compiles without errors



Iteration 2.2: Implement Pure Fade
Action: Add Pure Fade variant to factory

Code: [See Pure Fade implementation in Variant Factory]

Test:

npm run dev
# Press Ctrl+Shift+6 to jump to Pure Fade # Click IrisOrb ? L2
# Click node ? L3


Expected:

Nodes fade in quickly (0.3s)

No rotation, no complex effects

Navigation works

Success: Pure Fade works, navigation works



Iteration 2.3: Implement Pop Out
Action: Add Pop Out variant to factory

Code: [See Pop Out implementation in Variant Factory]

Test:

npm run dev
# Press Ctrl+Shift+5 to jump to Pop Out # Click IrisOrb ? L2
# Watch for:
#	- Spinning (720°)

#	- Scale overshoot (1.4) #	- Opacity dip at peak

Expected Console Output:

[Variants] Getting pop-out for index 0 [Variants] Getting pop-out for index 1
...


Expected Visual:

Nodes spin while growing

Brief fade at peak scale

Settles smoothly

Success: Pop Out works, fade-at-peak visible, navigation works



Phase 3: Medium Complexity (4-5 hours) 

Iteration 3.1: Implement Clockwork
Action: Add Clockwork variant to factory

Code: [See Clockwork implementation in Variant Factory]

Test:

npm run dev
# Press Ctrl+Shift+2 to jump to Clockwork # Click IrisOrb ? L2
# Watch for:
#	- Discrete steps (5 radial jumps) #	- Gear rotation (15° per step)
#	- Lock-in snap at end


Expected Console Output:

[Clockwork] X positions for angle -90: [0, 0, 0, 0, 0]
[Clockwork] Y positions for angle -90: [0, -50, -100, -150, -200] [Variants] Getting clockwork for index 0

Expected Visual:

Stepped mechanical motion (not smooth)

Gear turning effect

Click into place at end

Success: Clockwork feels mechanical, navigation works



Iteration 3.2: Add Counter-Rotation for Clockwork
Action: Modify hexagonal-node.tsx to counter-rotate content

Code: [See Content Counter-Rotation section]

Test:

Icons should stay upright during gear rotation

Labels should not spin

Success: Icons remain upright, readable throughout



Phase 4: High Complexity (6-8 hours) 

Iteration 4.1: Implement Slot Machine
Action: Add Slot Machine variant to factory

Code: [See Slot Machine implementation in Variant Factory]

Test:

npm run dev
# Press Ctrl+Shift+3 to jump to Slot Machine # Open Chrome DevTools ? Performance tab
# Start recording
# Click IrisOrb ? L2 # Stop recording
# Check FPS


Expected Console Output:

[SlotMachine] Wobble for angle -90: [0, -50, 50, -30, 20, -200] [Variants] Getting slot-machine for index 0

Expected Visual:

Heavy blur during spin

Vertical wobble

Blur clears as it settles

Bloom flash at end

Performance Check:

FPS should be > 50

If < 50, reduce blur to 10px max

Success: Slot Machine works, FPS acceptable, navigation works



Iteration 4.2: Implement Holographic Phase
Action: Add Holographic variant to factory

Code: [See Holographic implementation in Variant Factory]

Test:

npm run dev
# Press Ctrl+Shift+4 to jump to Holographic # Watch for:
#	- Wireframe appearance
#	- Color shifting (hue rotation) #	- Glitch flicker
#	- 3D flip effect


Expected Console Output:

[Variants] Getting holographic for index 0


Expected Visual:

Edge-on to face-on flip

RGB color glitches

Opacity flickers

Stabilizes smoothly

Performance Check:

FPS should be > 45

If < 45, simplify to 4 filter keyframes

Success: Holographic works (even if simplified), navigation works



Phase 5: Polish (2 hours) 

Iteration 5.1: Remove Debug Logs
Action: Wrap all console.log in DEBUG check

Code:
const DEBUG = process.env.NODE_ENV === 'development'; if (DEBUG) {
console.log('[Component] Message');
}


Test:

NODE_ENV=production npm run build


Success: No console logs in production build



Iteration 5.2: Performance Profile All Transitions
Action: Test each transition in Chrome DevTools

Test:

# For each transition:
# 1. Open DevTools ? Performance # 2. Start recording
# 3. Trigger transition L2?L3

# 4. Stop recording # 5. Check FPS

Target FPS:

Radial Spin: 60

Clockwork: 60

Slot Machine: 50+

Holographic: 45+

Pop Out: 60

Pure Fade: 60

If any transition fails: Simplify it



Iteration 5.3: Documentation
Action: Create TRANSITIONS.md documentation

Content:
# IRISVOICE Transitions ## Available Transitions
- Radial Spin (default)
- Clockwork (mechanical)
- Slot Machine (playful)
- Holographic (sci-fi)
- Pop Out (energetic)
- Pure Fade (minimal)

## Dev Controls
- Ctrl+Shift+T: Cycle
- Ctrl+Shift+1-6: Jump to specific
- Ctrl+Shift+R: Reset

## Performance Notes
[Document any issues or optimizations]




TESTING REQUIREMENTS

Manual Test Checklist
After EVERY iteration:

TypeScript compiles without errors

No runtime errors in console

L1 ? L2 transition works

L2 ? L3 transition works

L3 ? L2 back navigation works

L2 ? L1 collapse works

Current transition displays correctly

Keyboard shortcuts work

After completing each transition:

Entry animation looks correct

Exit animation looks correct

Timing feels right (not too fast/slow)

Visual effects work (blur, filters, etc.)

Icons stay upright (if counter-rotation needed)

Navigation is not broken

Before marking phase complete:

All transitions in phase work independently

Can cycle through all transitions

No console errors or warnings

Performance is acceptable (see targets)

Navigation has not regressed



Performance Targets

TransitionTarget FPSAcceptable FPSAction if BelowRadial Spin6055Investigate (already working)Clockwork6055Simplify rotationSlot Machine6050Reduce blur to 10pxHolographic5045Reduce keyframes to 4Pop Out6055Simplify easingPure Fade6060Should always be 60


ITERATION LOOP PROCESS

Loop Workflow

1. Start Iteration
?
2. Plan the change (what file, what code)
?
3. Make ONE change
?
4. Compile check (npx tsc --noEmit)
?
5. Has errors? ? YES ? Rollback, try different approach
? NO
6. Run dev server (npm run dev)
?
7. Test navigation (L1?L2?L3?L2?L1)
?
8. Navigation broken? ? YES ? Rollback, try different approach
? NO
9. Check console for errors
?
10. Has errors? ? YES ? Rollback, try different approach
? NO
11. Log success
?

12. Is phase complete? ? NO ? Next iteration
? YES
13. Advance to next phase




Console Logging Standards
Every function should log:

function myFunction(param: string) { console.log('[ComponentName] Action starting:', param);

// ... do work ...

console.log('[ComponentName] Action completed successfully');
}


Format:

[ComponentName] Action: details


Examples:

[TransitionContext] Changing type: radial-spin ? clockwork [Variants] Getting clockwork for index 2
[Clockwork] X positions for angle 30: [0, 25, 50, 75, 100] [HexagonalNode] Rendering with clockwork transition




SUCCESS CRITERIA

Phase 1 Complete When:

TransitionContext created and exports correctly

App wrapped with TransitionProvider

Context visible in React DevTools

Keyboard shortcuts respond correctly

Dev indicator shows current transition

L2?L3 navigation still works perfectly

No console errors

No TypeScript errors



Phase 2 Complete When:

Pure Fade implemented and works

Pop Out implemented and works

Can switch between them with keyboard

Both transitions look correct visually

Navigation works with both

No performance issues

No console errors



Phase 3 Complete When:

Clockwork implemented and works

Discrete stepping is visible

Gear rotation effect works

Icons stay upright (counter-rotation)

Feels mechanical and precise

Navigation still works

No console errors



Phase 4 Complete When:

Slot Machine implemented and works

Blur effects work (reduce if needed)

Wobble motion is visible

Bloom effect on lock-in

FPS > 50

Holographic implemented and works

Filter effects work (simplify if needed)

3D rotation works

FPS > 45

Navigation still works

No console errors



Phase 5 Complete When:

Debug logs removed from production

All transitions profiled for performance

Documentation created

Final navigation test passes

Ready to ship!



Overall Success = All These Are True:

All 6 transitions implemented

All transitions look correct

Navigation NEVER broke during implementation

Keyboard shortcuts work

Performance targets met

No console errors in production

Code is clean and commented

Documentation exists



EMERGENCY PROCEDURES

If Navigation Breaks
STOP IMMEDIATELY

1. Identify last file changed

2. Revert that file:

git checkout -- path/to/file


3. Test navigation again

4. If still broken, revert more files

5. Once working, document what broke it

6. Try a different approach



If TypeScript Won't Compile
1. Read the error message carefully

2. Check the file mentioned in error

3. Fix the type issue

4. If stuck, ask for help with specific error

5. Don't proceed until it compiles



If Performance is Bad
1. Open Chrome DevTools ? Performance

2. Record during transition

3. Identify bottleneck

4. Simplify the transition:

Reduce blur amount

Remove filter keyframes

Simplify easing

5. Test again



If Stuck for > 30 Minutes
1. Stop and take a break

2. Review what you were trying to do

3. Check if there's a simpler approach

4. Ask for help with specific question

5. Don't keep trying the same failing approach



FINAL REMINDERS

Before You Start:

Read all critical safety rules

Understand the iteration loop

Know how to test navigation

Know how to rollback changes

Have dev environment ready

During Implementation:

Follow iteration template for every change

Test after every change

Log everything to console

Don't skip testing

Rollback immediately if something breaks

After Each Phase:

Verify all checklist items

Test navigation thoroughly

Check console for warnings

Profile performance

Document any issues



YOU ARE READY!
You have:

 Complete specifications for all 6 transitions  Safety rules to protect navigation
 Clear implementation phases  Testing requirements
 Iteration loop process

 Code examples and helpers  Emergency procedures
Estimated Time: 18-22 hours over 3-4 days

Implementation Order:

1. Phase 1: Infrastructure (2h)

2. Phase 2: Pure Fade + Pop Out (4h)

3. Phase 3: Clockwork (4h)

4. Phase 4: Slot Machine + Holographic (7h)

5. Phase 5: Polish (2h)

Start with Phase 1, Iteration 1.1: Create TransitionContext

Good luck! 



END OF AI AGENT IMPLEMENTATION PROMPT
